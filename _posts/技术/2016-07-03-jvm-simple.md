---
layout: post
title:  JAVA JVM 简介
date: 2016/7/03 16:33:54 
categories:
- 技术
tags:
- Java
---

## JVM（Java Virtual Machine）
业界的三大java虚拟机：Oracle hotspot（后来被sun收购。名字源于：热点代码探测。最后独立用在1.4版本的JDK，后来衍生出了开源的Open JDK，也就是现在默认centos安装的jdk）、Oracle JRockit VM、IMB J9 VM。

## java运行时内存区域划分  
![jvm-pic01][image-1]

1. **程序计数器（Program Counter Register）：**

	一块较小的内存空间，被分配在cpu上。他的作用可以看作是线程执行的字节码的行号指示器。比如方法的执行的判断、分支、循环等。或者可以理解成为指针。是线程私有的内存空间，若执行的是java方法，则是一个地址，native方法则指示器是null。此区域是唯一一个在java中没有OutOfMemoryError的地址
2. **java虚拟机栈(JVM Stacks):**

	程序执行时候会产生一个**栈帧**，用于存储 **局部变量表、动态链接、操作数、方法出口**等信息。方法执行过程就是在jvm中的出栈和入栈的过程。局部变量表中存放的是各种类型：boolean、byte、char 8种常用的类型；引用类型：存放指向对象的内存地址。内存空间在编译期间确定，运行期间不变。有两种异常情况：StackOverFlowError和OutOfMemoryError。
3. **本地方法栈（Native Method Stacks）**

	用来处理java中的本地方法的，比如hashCode()、wait()等方法。他们都是依赖于操作系统底层。我们常说的sun的jvm本地方法栈就是java虚拟机栈；
4. **堆（Heap）**


	堆是内存中比较重要的一块，因为java所有对象的实体都会存在这里，相对于java的性能优化等等。可以通过-Xmx（最大内存）和-Xms（最小内存）来控制堆的大小，32位默认是2g，64位不限制；堆上面的对象实例和数组在上面的存储，通过JIT技术实现垃圾回收的算法，使得内存变得更加的优化。
5. **方法区（Method Area）**

	属于线程共享区域，用于加载类信息、常亮、静态变量等数据。一般方法区属于持久代(除了持久代，还有新生代、旧生代。)**运行时常量：**主要用于在编译中产生字面量（常量）和引用，一般在编译期间就能确定，有时候也会在运行时将常亮放入常量池；

## 栈空间垃圾回收（Garbage Collection）
java的垃圾回收和c++不一样，不需要程序员自己去执行回收gc操作

1. 垃圾回收不会按照程序员要求进行gc操作
2. 垃圾回收不会及时清理内存，尽管有时候程序员需要额外的内存
3. 程序员不能对垃圾回收进行控制

垃圾回收可以节约内存，带来程序的高效运行，造成不必要的系统异常。而在程序存储区间内，程序计数器、jvm栈、本地方法栈因为是线程同步的，随线程的周期销毁，会自动释放自己的内存空间。所以只有方法区和堆需要gc操作。关于回收，简单的说就是某一个对象不需要引用的时候，就可以被回收。简单粗暴的方法就是给方法添加一个引用计数器，分别记录当前方法线程被引用的数量，若一定时间是0的状态，则被回收。但是这种算法对于对象的相互引用就无法判断的，所以jvm采用的是 **根搜索算法** 如图所示：

![][image-2]

看图很简单理解，从下向上查找对象的引用，若不存在GC Roots节点的引用，则抛弃对象，但是有个特殊条件：当对销毁前会调用finalize（）方法，此方法由jni操作，用于判断对象是否还存在引用，若不存在和root节点的关联，则彻底销毁。若存在则不进行销毁。

在jdk1.2引入了强软弱虚引用、在gc操作时候有不同的意义

1. 强引用(Strong Reference)：刚刚被new出来的对象。他的特点是永远不会被回收
2. 软引用(Soft Reference)：用于存放缓存的引用，若是需要可以直接调用，不需要重新分配内存空间，用于提高程序性能操作，是可有可无的。若当jvm内存紧张状态下是可以被回收的。
3. 弱引用(Weak Reference)：弱引用对象的声明，表示在垃圾回收时候一定会被回收操作，不管内存是否紧张。
4. 虚引用(Phantom Reference)：在调用回收前的finalize方法的时候，对引用记录的跟踪操作。jvm不会关注它，可以忽略不计

所以当这些情况类会被回收

1. 类的实例都被回收
2. 加载该类的classLoader被回收
3. 这个类所对应的反射类java.lang.Class没有被任何地方引用；

## 方法区的垃圾回收
前面说了新生代、旧生代、持久代是构成方法区的gc回收机制的要点。先看下方法区空间的分配模型
![][image-3]

- 新生代（New Generation或者Young Generation）：新建的对象都是有新生代来分配内存，分为Eden区和Eden区和Survivor，当Eden区域不足时候会转移到Survivor区。Survivor又分为S0：FromSpace和S1:ToSpace，三者比例默认是8：1：1，可以通过-XX:SurvivorRatio启动时候的分配比例，新生代的内存设置：-Xmn。这个在以后垃圾回收的算法有介绍。

- 旧生代（Old Generation）：多次回收后仍然存在的对象，比如缓存。他占用的内存大小：-Xmx 减去 -Xmn（总内存 - 新生代内存）

- 持久代（Permanent Generation）：在sun的jvm中的命名，存放常亮和类的信息，可通过-XX:PermSize及-XX:MaxPermSize，默认是16M-64M。


## 关于垃圾回收的算法

1. 标记-清除算法（Mark-Sweep）：对回收的对象做标记，然后进行回收操作。因为没有对其进行整理，所以在回收标记的对象会产生碎片
2. 复制算法（Copying）：将Survivor地区分为了s0和s1两块区域，在清理需要回收的空间时候，将有用的对象复制到s1区域，（当s1不足时候，就会借助持久代的内存临时存放）然后对Eden区域和S0区域完全清理。此算法适用于**新生代**
3. 标记-整理（或叫压缩）算法（Mark-Compact）：标记不需要回收的对象，然后移动到一块，使得内存连续，然后清除。此算法适用于**持久代**

## 垃圾收集器
![][image-4]

1. 串行GC（SerialGC）:最基本的收集器，使用单线程，让运行的线程暂停几毫秒，然后进行回收操作。这种收集方式适用于单核的cpu、使用在新生代空间暂停时间和不是非常要求很高的应用上，client级别的默认的gc方式。使用-XX:+UseSerialGC来强制指定。

2. 并行GC（ParNew）:和串行一样，只不过加入了多线程机制。可用在服务端（Server）上面，和CMS GC配合进行回收操作，所以将其放在服务端

3. 并行回收GC（Parallel Scavenge）:在扫描和复制过程中使用采用多线程方式进行。适用于多cpu、对暂停时间要求比较小的应用上面。server级别默认采取的方式。可用-XX:+UseParallelGC来强制指定，用-XX:ParallelGCThreads=4来指定线程数

4. CMS (Concurrent Mark Sweep)收集器:用来解决Serial GC响应停顿的问题，达到最短的回收时间，并发收集，低停顿的特点。他的执行分为四个阶段（从标记到清除）
	1. 初始标记(CMS initial mark)：查找标记出能够关联上gc root的节点的对象
	2. 并发标记(CMS concurrent mark)：根据gc root算法搜索对象是否真正存活。
	3. 重新标记(CMS remark)：在程序运行中的并发瞬间导致会有对象标记的变动，以此来修正并发标记时间。比初始化要长，但是比并发标记要短。
	4. 并发清除(CMS concurrent sweep)：对非标记的对象清除。

5. G1收集器：相比CMS收集器有了不少的改进，标记 - 整理。所以不会产生碎片问题。有比较精准的停顿。

6. Serial Old：是Serial的老年代版本、使用单线程执行收集操作。用在client模式下面的虚拟机。

7. Parallel Old：是Parallel Scavenge的老年代版本，使用多线程的 标记-整理 算法

8. RTSJ收集器：基于java实时编程。

### 关于CMS并发

优点：并发收集，减少收集停顿时间

缺点：

1. 在并发的阶段，会根据cpu开启相应的回收线程数量，导致占用cpu资源，降低了吞吐量。默认开启 (cpu数量+3)/4 个回收线程

2. 并发清除的时候，在这里会随着程序运行，产生的垃圾只有等到下次回收，称之为“浮动垃圾”。而且在老年代的内存空间中，除了收集线程，还需要有足够的应用程序线程使用，所以不能等到Full gc再来收集，默认的是68%就会激活收集，-XX:CMSInitiatingOccupancyFraction可以修改值，降低回收次数，提高性能。若因为数据量大收集失败则会启动Serial Old来收集，时间变长了。所以性能反而下降。

3. 使用标记-收集算法实现产生大量的碎片，如需要生产一个大对象，而找不到合适的空间，则不得不提前触发一次full gc。这个问题可以通过-XX:UseCMSCompactAtFullCollection对执行收集后进行整理碎片的操作，-XX:CMSFullGCBeforeCompaction设置多少次收集后，进行一次压缩操作。

## 调用gc()操作
gc方法的调用意味着按时需要在堆上面进行垃圾回收操作，在判断对象已经需要丢弃的状态下，对空间进行回收操作 System.gc() = Runtime.getRuntime().gc()；

## finalize()
只要是对栈内存空间的回收，比如某个非java对象的回收，例如调用C的free操作，用来给内存释放空间。

## 内存溢出
由于要求分配的虚拟机内存空间超出了系统所给予的空间，不能满足要求，然而系统会产生溢出

## 内存泄漏
程序对系统所分配的内存大量使用，处于一直占用的状态，所以其他的对象无法在其中创建内存区域，导致内存占用越来越多，然后产生泄露，这样一直下去，程序无法创建内存空间，也就无法运行了。


## 参考

本来是想将"深入理解jvm虚拟机"看一遍的，东西都比较概念，所以根据作者理解消化写的，若是参考原文比较好，坐着总结讲解的也比较全面：
[http://blog.csdn.net/zhangerqing/article/details/8214365][1]

[1]:	http://blog.csdn.net/zhangerqing/article/details/8214365

[image-1]:	{{site.baseurl}}/public/img/jvm-pic01.png
[image-2]:	http://img.my.csdn.net/uploads/201211/23/1353685206_5107.jpg
[image-3]:	http://img.my.csdn.net/uploads/201211/24/1353728416_1655.jpg
[image-4]:	http://img.my.csdn.net/uploads/201211/25/1353773614_1052.jpg
